#ifndef I_MODULE_EVENTS_GENERAL_H
#define I_MODULE_EVENTS_GENERAL_H

#include "base/pose/geodetic_position_3D.h"

#include "data/system_description.h"
#include "data_generic_command_item/command_item_components.h"
#include "data_generic_state_item/state_global_position.h"

#include "abstract_module_base.h"

namespace MaceCore
{

//!
//! \brief These represent events that any module may generate
//!
//! Events are messages generated by a module to be delivered to the core
//!
class IModuleEventsGeneral
{
public:

    //!
    //! \brief Event to notify the core that a new module has been attached to some MACE instance.
    //! \param sender Module that generated the new module. May be different than the module itself (Like and External Link)
    //! \param characterstic Characterstic that uniquly identifies the module on the MACE topology
    //! \param type Type of module
    //!
    virtual void Event_NewModule(const ModuleBase* sender, const ModuleCharacteristic &characterstic, const ModuleClasses &type) = 0;


    //!
    //! \brief Event to signify that a new vehicle is available
    //! \param sender Module that generated the vehicle. May be different than the vehicle itself if the vehicle came in over External Link
    //! \param publicID Public ID of vehicle, may be different of MACE's internal address
    //! \param vehicleModule MACE internal address of vehicle Module
    //!
    virtual void Events_NewVehicle(const ModuleBase *sender, const uint8_t publicID, const ModuleCharacteristic &vehicleModule) = 0;


    virtual void Event_ForceVehicleDataSync(const ModuleBase* sender, const int &targetSystemID) = 0;

    virtual void Event_IssueCommandSystemArm(const ModuleBase* sender, const CommandItem::ActionArm &command) = 0;

    virtual void Event_IssueCommandTakeoff(const ModuleBase* sender, const CommandItem::SpatialTakeoff &command) = 0;

    virtual void Event_IssueCommandLand(const ModuleBase* sender, const CommandItem::SpatialLand &command) = 0;

    virtual void Event_IssueCommandRTL(const ModuleBase* sender, const CommandItem::SpatialRTL &command) = 0;

    virtual void Event_IssueMissionCommand(const ModuleBase* sender, const CommandItem::ActionMissionCommand &command) = 0;

    virtual void Event_ChangeSystemMode(const ModuleBase *sender, const CommandItem::ActionChangeMode &command) = 0;

    virtual void Event_IssueGeneralCommand(const ModuleBase* sender, const std::shared_ptr<CommandItem::AbstractCommandItem> &command) = 0;

    virtual void Event_GetMission(const void* sender, const MissionItem::MissionKey &key) = 0;
    virtual void Event_GetOnboardMission(const void* sender, const int &systemID, const MissionItem::MISSIONTYPE &type) = 0;
    virtual void Event_GetCurrentMission(const void* sender, const int &systemID) = 0;

    virtual void RequestClearVehicleMission(const void* sender, const Data::SystemDescription &systemID) = 0;
    virtual void RequestVehicleClearGuidedMission(const void* sender, const int &vehicleID) = 0;

    virtual void Event_GetHomePosition(const void* sender, const int &vehicleID) = 0;
    virtual void Event_SetHomePosition(const ModuleBase *sender, const CommandItem::SpatialHome &vehicleHome) = 0;

    virtual void Event_SetGridSpacing(const void* sender, const double &gridSpacing) = 0;

    /*
     * The following 3 virtual functions are highly dependent currently since they are all going to use the
     * global origin to determine and decipher the local position that are in the boundary lists. This needs to be
     * generalized and fixed.
     */
    virtual void Event_SetGlobalOrigin(const void* sender, const mace::pose::GeodeticPosition_3D &globalHome) = 0;
};

} //End MaceCore Namespace

#endif // I_MODULE_EVENTS_GENERAL_H
